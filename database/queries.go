package database

import (
	"database/sql"
	"log"
	"math"
	"strings"

	"github.com/blockloop/scan/v2"
	"github.com/lib/pq"
	"github.com/teris-io/shortid"
)

var resultsPerPage int = 10

func GetRingtones(search string, category int, sortBy string, phones []int, effects []int, autoGenerated bool, page int, authorID int) ([]RingtoneModel, int, error) {
	var ringtones []RingtoneModel
	var rows *sql.Rows
	var err error

	query := `WITH all_ringtones AS ( SELECT id, display_id, name, ARRAY ( SELECT p.name FROM phone_and_ringtone par INNER JOIN phone p ON p.id = par.phone_id WHERE par.ringtone_id = ringtone.id ) as phone_names, ARRAY ( SELECT par.phone_id FROM phone_and_ringtone par WHERE par.ringtone_id = ringtone.id ) as phone_ids, effect_id, author_id, downloads, time_added, category, auto_generated, glyphs FROM ringtone ), ringtones_matched AS ( SELECT * FROM all_ringtones WHERE ( phone_ids && $2 OR COALESCE(array_length($2, 1), 0) = 0 ) AND ( effect_id = ANY ($3) OR COALESCE(array_length($3, 1), 0) = 0 ) AND ( $4 = 0 OR category = $4 ) ) SELECT rm.id, rm.display_id, rm.name, ( CASE WHEN $1 = '' THEN (rm.downloads::FLOAT) / GREATEST(MAX(rm.downloads) OVER (), 1) ELSE similarity (concat(rm.name, u.name), $1) END ) AS score, u.id AS author_id, u.name AS author_name, rm.downloads, rm.phone_names, rm.category, rm.auto_generated, rm.glyphs, e.name AS effect_name, COUNT(*) OVER () AS results, COUNT(*) FILTER (WHERE up IS TRUE) - COUNT(*) FILTER (WHERE up IS FALSE) AS votes, (CASE WHEN $8 = 0 THEN 0 ELSE (CASE WHEN (SELECT up FROM vote WHERE ringtone_id = rm.id AND author_id = $8) IS FALSE THEN 2 WHEN (SELECT up FROM vote WHERE ringtone_id = rm.id AND author_id = $8) IS TRUE THEN 1 ELSE 0 END) END) AS user_vote FROM ringtones_matched rm INNER JOIN effect e ON rm.effect_id = e.id INNER JOIN author u ON rm.author_id = u.id LEFT JOIN vote v ON rm.id = v.ringtone_id WHERE ( similarity (concat(rm.name, u.name), $1) > 0.05 OR LENGTH($1) < 3 ) AND (auto_generated = FALSE OR $5 = TRUE) GROUP BY (rm.id, rm.display_id, rm.name, rm.downloads, rm.phone_names, rm.category, rm.auto_generated, rm.glyphs, u.id,u.name, e.name, rm.time_added)`
	if search != "" {
		query += ` ORDER BY score DESC, rm.name`
	} else {
		switch sortBy {
		case "popular":
			query += ` ORDER BY score DESC, rm.name`
		case "latest":
			query += ` ORDER BY rm.time_added DESC, rm.name`
		case "name (a-z)":
			query += ` ORDER BY rm.name, score DESC`
		default:
			query += ` ORDER BY score DESC, rm.name`
		}
	}
	query += ` LIMIT $6 OFFSET $7;`

	rows, err = DB.Query(query, search, pq.Array(phones), pq.Array(effects), category, autoGenerated, resultsPerPage, (page-1)*resultsPerPage, authorID)
	if err != nil {
		return ringtones, 0, err
	}

	err = scan.Rows(&ringtones, rows)
	if err != nil {
		return ringtones, 0, err
	}

	var numberOfPages int = 0
	if len(ringtones) != 0 {
		numberOfPages = int(math.Ceil(float64(ringtones[0].NumberOfResults) / float64(resultsPerPage)))
	}

	return ringtones, numberOfPages, nil
}

func GetRingtonesByAuthor(authorName string, page int) ([]RingtoneModel, int, error) {
	var ringtones []RingtoneModel
	var rows *sql.Rows
	var err error

	rows, err = DB.Query(`WITH ringtones_matched AS ( SELECT r.id, r.display_id, r.name, ARRAY ( SELECT p.name FROM phone_and_ringtone par INNER JOIN phone p ON p.id = par.phone_id WHERE par.ringtone_id = r.id ) as phone_names, r.effect_id, r.author_id, r.downloads, r.glyphs, r.auto_generated, (downloads::FLOAT) / GREATEST(MAX(downloads) OVER (), 1) AS score, COUNT(*) FILTER ( WHERE up IS TRUE ) - COUNT(*) FILTER ( WHERE up IS FALSE ) AS votes FROM ringtone r FULL OUTER JOIN vote v ON v.ringtone_id = r.id WHERE r.author_id = ( SELECT id FROM author WHERE name = $1 ) GROUP BY ( r.id, r.display_id, r.name, r.downloads, phone_names, r.category, r.auto_generated, r.glyphs, r.time_added ) ) SELECT rm.id, rm.display_id, rm.name, rm.score, u.id AS author_id, u.name AS author_name, rm.downloads, rm.phone_names, rm.glyphs, rm.auto_generated, e.name AS effect_name, rm.votes, COUNT(*) OVER () AS results FROM ringtones_matched rm INNER JOIN effect e ON rm.effect_id = e.id INNER JOIN author u ON rm.author_id = u.id ORDER BY score DESC LIMIT $2 OFFSET $3;`, authorName, resultsPerPage, (page-1)*resultsPerPage)
	if err != nil {
		log.Println(1)
		return ringtones, 0, err
	}

	err = scan.Rows(&ringtones, rows)
	if err != nil {
		log.Println(2)
		return ringtones, 0, err
	}

	var numberOfPages int = 0
	if len(ringtones) != 0 {
		numberOfPages = int(math.Ceil(float64(ringtones[0].NumberOfResults) / float64(resultsPerPage)))
	}

	return ringtones, numberOfPages, nil
}

func CreateRingtone(name string, category int, phones []int, effect int, authorID int, autoGenerated bool, glyphData string) (string, error) {
	displayID, err := shortid.Generate()
	if err != nil {
		return "", err
	}

	var ringtoneID int
	err = DB.QueryRow(`INSERT INTO ringtone (display_id, name, category, effect_id, author_id, auto_generated, glyphs) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id;`, displayID, name, category, effect, authorID, autoGenerated, glyphData).Scan(&ringtoneID)
	if err != nil {
		return "", err
	}
	_, err = DB.Exec(`INSERT INTO phone_and_ringtone (ringtone_id, phone_id) SELECT $1, UNNEST($2::int[])`, ringtoneID, pq.Array(phones))
	if err != nil {
		return "", err
	}
	return displayID, nil
}

func DeleteRingtone(displayID string, authorID int) error {
	_, err := DB.Exec(`DELETE FROM ringtone WHERE display_id = $1 AND (author_id = $2 OR $2 = 1);`, displayID, authorID)
	return err
}

func GetRingtone(displayID string, authorID int) (RingtoneModel, error) {
	var ringtone RingtoneModel
	rows, err := DB.Query(`SELECT r.id, r.display_id, r.name, ARRAY ( SELECT p.name FROM phone_and_ringtone par INNER JOIN phone p ON p.id = par.phone_id WHERE par.ringtone_id = r.id ) as phone_names, u.id AS author_id, u.name AS author_name, e.name AS effect_name, r.downloads, COUNT(*) FILTER ( WHERE v.up IS TRUE ) - COUNT(*) FILTER ( WHERE v.up IS FALSE ) AS votes, ( CASE WHEN $2 = 0 THEN 0 WHEN ( SELECT up FROM vote WHERE author_id = $2 AND ringtone_id = r.id ) IS TRUE THEN 1 WHEN ( SELECT up FROM vote WHERE author_id = $2 AND ringtone_id = r.id ) IS FALSE THEN 2 ELSE 0 END ) AS user_vote FROM ringtone r INNER JOIN effect e ON r.effect_id = e.id INNER JOIN author u ON r.author_id = u.id FULL OUTER JOIN vote v ON r.id = v.ringtone_id WHERE r.display_id = $1 GROUP BY ( r.id, r.display_id, r.name, u.id, u.name, e.name, r.downloads );`, displayID, authorID)
	if err != nil {
		log.Println(err.Error())
		return ringtone, err
	}
	err = scan.Row(&ringtone, rows)
	return ringtone, err
}

func RenameRingtone(displayID string, name string, authorID int) error {
	_, err := DB.Exec(`UPDATE ringtone SET name = $1 WHERE display_id = $2 AND (author_id = $3 OR $3 = 1);`, name, displayID, authorID)
	return err
}

func RenameRingtoneByDisplayID(displayID string, name string, authorID int) error {
	_, err := DB.Exec(`UPDATE ringtone SET name = $1 WHERE display_id = $2 AND (author_id = $3 OR $3 = 1);`, name, displayID, authorID)
	return err
}

func RingtoneIncreaseDownload(displayID string) error {
	_, err := DB.Exec(`UPDATE ringtone SET downloads = downloads + 1 WHERE display_id = $1;`, displayID)
	return err
}

// func RingtoneIncreaseNotWorking(id int) error {
// 	_, err := DB.Exec(`UPDATE ringtone SET not_working = not_working + 1 WHERE id = $1;`, id)
// 	return err
// }

func GetPhones() ([]PhoneModel, error) {
	var phones []PhoneModel
	var rows *sql.Rows
	var err error

	rows, err = DB.Query(`SELECT * FROM phone ORDER BY name;`)
	if err != nil {
		log.Println(err.Error())
		return phones, err
	}

	err = scan.Rows(&phones, rows)
	if err != nil {
		log.Println(2)
		return phones, err
	}

	return phones, nil
}

func GetEffects() ([]EffectModel, error) {
	var effects []EffectModel
	var rows *sql.Rows
	var err error

	rows, err = DB.Query(`SELECT * FROM effect ORDER BY id;`)
	if err != nil {
		log.Println(err.Error())
		return effects, err
	}

	err = scan.Rows(&effects, rows)
	if err != nil {
		log.Println(2)
		return effects, err
	}

	return effects, nil
}

func GetAuthor(id int) (AuthorModel, error) {
	var author AuthorModel
	rows, err := DB.Query(`SELECT * FROM author WHERE id = $1;`, id)
	if err != nil {
		return author, err
	}
	err = scan.Row(&author, rows)
	return author, err
}

func GetAuthorByName(name string) (AuthorModel, error) {
	var author AuthorModel
	rows, err := DB.Query(`SELECT * FROM author WHERE name = $1;`, name)
	if err != nil {
		return author, err
	}
	err = scan.Row(&author, rows)
	return author, err
}

func CreateAuthor(name string, email string) (int, error) {
	var authorID int

	email = strings.ToLower(email)

	err := DB.QueryRow(`WITH res AS (INSERT INTO author (name, email) VALUES ($1, $2) ON CONFLICT(email) DO NOTHING RETURNING id) SELECT id FROM res UNION ALL SELECT id FROM author WHERE email = $2 LIMIT 1;`, name, email).Scan(&authorID)
	if err != nil {
		return 0, err
	}
	return authorID, nil

}

func RenameAuthor(id int, newName string) error {
	_, err := DB.Exec(`UPDATE author SET name = $1 WHERE id = $2;`, newName, id)
	return err
}

func Vote(userID int, displayID string, vote int) error {
	var err error
	if vote == 0 {
		_, err = DB.Exec(`DELETE FROM vote WHERE author_id = $1 AND ringtone_id = (SELECT id FROM ringtone WHERE display_id = $2)`, userID, displayID)
	} else {
		_, err = DB.Exec(`INSERT INTO vote (author_id, ringtone_id, up) SELECT $1, r.id, $3 FROM ringtone r WHERE r.display_id = $2 AND r.author_id != $1 ON CONFLICT (author_id, ringtone_id) DO UPDATE SET up = EXCLUDED.up;`, userID, displayID, vote == 1)
	}
	return err
}
